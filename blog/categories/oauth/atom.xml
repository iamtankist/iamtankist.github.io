<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: OAuth | Yet Another Tecnical Blog]]></title>
  <link href="http://iamtankist.github.io/blog/categories/oauth/atom.xml" rel="self"/>
  <link href="http://iamtankist.github.io/"/>
  <updated>2014-01-21T14:19:15+01:00</updated>
  <id>http://iamtankist.github.io/</id>
  <author>
    <name><![CDATA[Armen Mkrtchyan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[OAuth2 Explained: Part 4 - Implementing Custom Grant Type with Symfony2 and FOSOAuthServerBundle]]></title>
    <link href="http://iamtankist.github.io/blog/2013/08/20/oauth2-explained-part-4-implementing-custom-grant-type-symfony2-fosoauthserverbundle/"/>
    <updated>2013-08-20T14:05:00+02:00</updated>
    <id>http://iamtankist.github.io/blog/2013/08/20/oauth2-explained-part-4-implementing-custom-grant-type-symfony2-fosoauthserverbundle</id>
    <content type="html"><![CDATA[<ul>
<li><a href="http://blog.tankist.de/blog/2013/07/16/oauth2-explained-part-1-principles-and-terminology/">Part 1 &ndash; Principles and Terminology</a></li>
<li><a href="http://blog.tankist.de/blog/2013/07/17/oauth2-explained-part-2-setting-up-oauth2-with-symfony2-using-fosoauthserverbundle/">Part 2 &ndash; Setting up OAuth2 with Symfony2 using FOSOAuthServerBundle</a></li>
<li><a href="http://blog.tankist.de/blog/2013/07/18/oauth2-explained-part-3-using-oauth2-with-your-bare-hands/">Part 3 &ndash; Using OAuth2 with your bare hands</a></li>
<li><a href="http://blog.tankist.de/blog/2013/08/20/oauth2-explained-part-4-implementing-custom-grant-type-symfony2-fosoauthserverbundle/">Part 4 &ndash; Implementing Custom Grant Type</a></li>
<li>Part 5 &ndash; Implementing OAuth2 Client with Symfony2</li>
</ul>


<h1>We need something custom</h1>

<p>In the previous part we have tested several standard grant-types that come out-of the box with FOSOAuthServerBundle, but probably you will need something more specific for your application. For example it is common to assign specific user API keys to allow access to the application. That way you don&rsquo;t expose user password to the API on the other you can control API keys, make them expire, revoke, etc.</p>

<p>It&rsquo;s possible to define your custom grant-type, which will authenticate the user based on his API key.</p>

<h2>Preparations</h2>

<p>First, let&rsquo;s modify the User entity. It needs to hold the API key from now on.</p>

<!-- more -->


<p>``` php</p>

<pre><code>&lt;?php 

namespace Acme/DemoBundle/Entity;

use Symfony/Component/Security/Core/User/UserInterface;
use Doctrine/ORM/Mapping as ORM;

/**
 * Acme/UserBundle/Entity/User
 *
 * @ORM/Table(name="acme_users")
 * @ORM/Entity(repositoryClass="Acme/DemoBundle/Repository/UserRepository")
 */
class User implements UserInterface, /Serializable
{

    // ... many other great properties on the class

    /**
     * @ORM/Column(type="string", length=32)
     */
    private $apiKey;

    /**
     * @param mixed $apiKey
     */
    public function setApiKey($apiKey)
    {
        $this-&gt;apiKey = $apiKey;
    }

    /**
     * @return mixed
     */
    public function getApiKey()
    {
        return $this-&gt;apiKey;
    }
}
</code></pre>

<p>```</p>

<p>I&rsquo;ll use built-in doctrine command which ships with Symfony2 Standard Edition for the simplicity</p>

<p>``` bash</p>

<pre><code>php app/console doctrine:schema:update --force
</code></pre>

<p>```</p>

<p>but for the project which will hit the Internets I would highly recommend to use <a href="https://github.com/doctrine/DoctrineMigrationsBundle">Doctrine Migrations</a> instead.</p>

<p>Use your favorite DB management tool to set some random api keys to some users on the user table.</p>

<p>Now it&rsquo;s time to get to the topic</p>

<h2>Implementing custom Grant Type</h2>

<p>You will need a class which implements the logic for verifying the provided apiKey agains database.</p>

<p>``` php</p>

<pre><code>&lt;?php

// src/Acme/DemoBundle/OAuth/ApiKeyGrantExtension.php

namespace Acme\DemoBundle\OAuth;

use Doctrine\Common\Persistence\ObjectRepository;
use FOS\OAuthServerBundle\Storage\GrantExtensionInterface;
use OAuth2\Model\IOAuth2Client;

/**
 * Play at bingo to get an access_token: May the luck be with you!
 */
class ApiKeyGrantExtension implements GrantExtensionInterface
{

    private $userRepository;

    public function __construct(ObjectRepository $userRepository)
    {
        $this-&gt;userRepository = $userRepository;
    }

    /*
     * {@inheritdoc}
     */
    public function checkGrantExtension(IOAuth2Client $client, array $inputData, array $authHeaders)
    {
        $user = $this-&gt;userRepository-&gt;findOneByApiKey($inputData['api_key']);

        if ($user) {
            //if you need to return access token with associated user
            return array(
                'data' =&gt; $user
            );

            //if you need an anonymous user token
            return true;
        }

        return false;
    }
}
</code></pre>

<p>```</p>

<p>Now we need to register this class as a service tagged as grant extension in DIC</p>

<p>``` xml</p>

<pre><code>// src/Acme/DemoBundle/Resources/config/services.xml

&lt;services&gt;

    ...

    &lt;service id="platform.grant_type.api_key" class="Acme\DemoBundle\OAuth\ApiKeyGrantExtension"&gt;
        &lt;tag name="fos_oauth_server.grant_extension" uri="http://platform.local/grants/api_key" /&gt;
        &lt;argument type="service" id="platform.user.repository"/&gt;
    &lt;/service&gt;

    ...

&lt;/services&gt;
</code></pre>

<p>```</p>

<p>Note: <a href="http://platform.local/grants/api_key">http://platform.local/grants/api_key</a> it must not be a valid url that leads you somewhere, it&rsquo;s just a way to namespace your URL according to the standard. Also it&rsquo;s a reference to your extension as you will see in the next section.</p>

<h2>Time to test</h2>

<p>First you need to create a client which grants this custom grant extension</p>

<pre><code>php app/console acme:oauth-server:client:create --grant-type="http://platform.local/grants/api_key" 
</code></pre>

<p>Expected output looks like this</p>

<pre><code>Added a new client with public id CLIENT_ID, secret CLIENT_SECRET
</code></pre>

<p>Next we need to fire an http request against the oauth provider with this credentials and api key</p>

<pre><code>curl -XGET "http://portal.local/oauth/v2/token?grant_type=http://platform.local/grants/api_key&amp;client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET&amp;api_key=API_KEY"
</code></pre>

<p>If the API_KEY is one of the keys you had set on the user table, you will get success response</p>

<pre><code>{"access_token":"OTQ2OTNkY2VkMmI3MzQ4MDUwMTY2YjUwOWZhMjBjYmM5NGI2N2UwNDIwNDhkNTY2MWNlNTk1MmE5MmNhMTJjNA","expires_in":3600,"token_type":"bearer","scope":null,"refresh_token":"NTBkZDgxOGJiYmExYzZhNzQ5MmMwNTZjNjAyYzQzMmU1OTQ2NmRmMzljYzQxNmM3OGQ5ZDhhMjRhMjZiZTZmMA"}
</code></pre>

<p>otherwise an</p>

<pre><code>{"error":"invalid_grant"}
</code></pre>

<h2>Summary</h2>

<p>As you see implementing custom authorisation mechanisms with OAuth2 and Symfony2 using FOSOAuthServerBundle is really easy. One other example when you need this, is when you implement an API which supports a mobile app, and one of the features is Facebook login on the mobile app. Then you need to somehow login user on the backend as well. The correct way to do this is passing a facebook access token through a custom grant extension to the backend, backend then makes a request to the facebook, to make sure the token is correct, finds out user from it, and gives back the mobile app an access_token with a backend user associated to it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OAuth2 Explained: Part 3 - Using OAuth2 with your bare hands]]></title>
    <link href="http://iamtankist.github.io/blog/2013/07/18/oauth2-explained-part-3-using-oauth2-with-your-bare-hands/"/>
    <updated>2013-07-18T14:35:00+02:00</updated>
    <id>http://iamtankist.github.io/blog/2013/07/18/oauth2-explained-part-3-using-oauth2-with-your-bare-hands</id>
    <content type="html"><![CDATA[<ul>
<li><a href="http://blog.tankist.de/blog/2013/07/16/oauth2-explained-part-1-principles-and-terminology/">Part 1 &ndash; Principles and Terminology</a></li>
<li><a href="http://blog.tankist.de/blog/2013/07/17/oauth2-explained-part-2-setting-up-oauth2-with-symfony2-using-fosoauthserverbundle/">Part 2 &ndash; Setting up OAuth2 with Symfony2 using FOSOAuthServerBundle</a></li>
<li><a href="http://blog.tankist.de/blog/2013/07/18/oauth2-explained-part-3-using-oauth2-with-your-bare-hands/">Part 3 &ndash; Using OAuth2 with your bare hands</a></li>
<li><a href="http://blog.tankist.de/blog/2013/08/20/oauth2-explained-part-4-implementing-custom-grant-type-symfony2-fosoauthserverbundle/">Part 4 &ndash; Implementing Custom Grant Type</a></li>
<li>Part 5 &ndash; Implementing OAuth2 Client with Symfony2</li>
</ul>


<h2>Preparations</h2>

<p>We&rsquo;ll need a controller that mimics a dummy API behavior for us.</p>

<!-- more -->


<p>``` php</p>

<pre><code>&lt;?php

namespace Acme\DemoBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\JsonResponse;

class ApiController extends Controller
{
    public function articlesAction()
    {
        $articles = array('article1', 'article2', 'article3');
        return new JsonResponse($articles);
    }

    public function userAction()
    {
        $user = $this-&gt;container-&gt;get('security.context')-&gt;getToken()-&gt;getUser();
        if($user) {
            return new JsonResponse(array(
                'id' =&gt; $user-&gt;getId(),
                'username' =&gt; $user-&gt;getUsername()
            ));
        }

        return new JsonResponse(array(
            'message' =&gt; 'User is not identified'
        ));

    }
}
</code></pre>

<p>```</p>

<h2>Let&rsquo;s Fail!</h2>

<p>Please keep in mind, that the point is to obtain access_token.</p>

<p>Why? Request</p>

<pre><code>PROVIDER_HOST/api/articles
</code></pre>

<p>What?</p>

<pre><code>{"error":"access_denied","error_description":"OAuth2 authentication required"}
</code></pre>

<p>Right. That&rsquo;s why. Our API is protected, we don&rsquo;t let everybody in. Let&rsquo;s try to do this again once we have the access_token at the end of the chapter.</p>

<h2>Registering OAuth Client</h2>

<p>First we need to create a Client and allow all possible grant types for it. Here&rsquo;s how to do that. Navigate to the project root of the provider (the one we created in <a href="http://blog.tankist.de/blog/2013/07/17/oauth2-explained-part-2-setting-up-oauth2-with-symfony2-using-fosoauthserverbundle/">previous part</a>) and then execute the following command. Client host represents a URL, where your client application is deployed. You will get redirected here if everything went as planned.</p>

<pre><code>php app/console acme:oauth-server:client:create --redirect-uri="CLIENT_HOST" --grant-type="authorization_code" --grant-type="password" --grant-type="refresh-token" --grant-type="token" --grant-type="client_credentials"
</code></pre>

<p>command should respond with something like</p>

<pre><code>Added a new client with public id 2_1y1zqhh7ws5c8kok8g8w88kkokos0wwswwwowos4o48s48s88w, secret 16eqpwofy5dwo4wggk4s40s80sgcs4gc0cwgwsc8k8w0k8sks4
</code></pre>

<p>Please keep those values somewhere in an easy accessible place, we will need those during this tutorial.
To keep URLs short and readable I&rsquo;ll refer to those as CLIENT_ID and CLIENT_SECRET in the future.</p>

<p>Let&rsquo;s start from the more complicated grant types and move on to the simpler ones.</p>

<h2>Authorization Code</h2>

<p>That&rsquo;s the most commonly used one, recommended to authorize end customers. A good example is the Facebook Login for websites. Here&rsquo;s how it works.</p>

<p>Request this url in the browser:</p>

<pre><code>PROVIDER_HOST/oauth/v2/auth?client_id=CLIENT_ID&amp;response_type=code&amp;redirect_uri=CLIENT_HOST
</code></pre>

<p>note: redirect_uri should be identical to the one provided on client creation, otherwise you will get a corresponding error message.</p>

<p>The page you are requesting will offer you a login, then authorization of the client permissions, once you confirm everything it will redirect you back to the url you provided in redirect_url. In our case, redirect will look like</p>

<pre><code>CLIENT_HOST/?code=Yjk2MWU5YjVhODBiN2I0ZDRkYmQ1OGM0NGY4MmUyOGM2NDQ2MmY2ZDg2YjUxYjRiMzAwZTY2MDQxZmUzODg2YQ
</code></pre>

<p>I&rsquo;ll refer to this long code parameter as CODE in the future. This code is stored on the Provider side, and once you request for the token, it can uniquely identify the client which made request and the user.</p>

<p>It&rsquo;s time to request the token</p>

<pre><code>PROVIDER_HOST/oauth/v2/token?client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET&amp;grant_type=authorization_code&amp;redirect_uri=http%3A%2F%2Fclinet.local%2F&amp;code=CODE
</code></pre>

<p>Most probably this request will fail. That&rsquo;s because CODE expires rather quickly. Fear not, just request first URL, repeat the process, prepare the second url in the text editor of your choice, copy in the code rather quickly, and you will get the desired result.</p>

<p>It&rsquo;s a JSON which contains access_token and looks like this</p>

<pre><code>{"access_token":"NjlmNDNiZTU4ZDY3ZGFlYTI5MGEzNDcxZWVmZDU4Y2E1NGJmZTJlMjNjNzc2M2E0MmZlZTk2ZjliMWE0MDQyNw","expires_in":3600,"token_type":"bearer","scope":null,"refresh_token":"ZGU2NzlhOTQ2MmRlY2YyYjAyMjBkYmJmMmJhMDllNTgyNmJkNmQxOWZlNGQ4NzczY2RiMThlNmRhMjBiYjFjNg"}
</code></pre>

<p>this suggests that access_token expires in 3600 seconds, and to refresh it you have the refresh token. We will discuss how to handle that later on this chapter.</p>

<h2>Implicit Grant</h2>

<p>It&rsquo;s similar to Authorization Code grant, it&rsquo;s just a bit simpler. You just need to make only one request, and you will get the access_token as a part of redirect URL, there&rsquo;s no need for second response. That&rsquo;s for the situations where you trust the user and the client, but you still want the user to identify himself in the browser.</p>

<pre><code>PROVIDER_HOST/oauth/v2/auth?client_id=2_1y1zqhh7ws5c8kok8g8w88kkokos0wwswwwowos4o48s48s88w&amp;redirect_uri=http%3A%2F%2Fclinet.local%2F&amp;response_type=token
</code></pre>

<p>then you will get redirected to</p>

<pre><code>CLIENT_HOST/#access_token=YWZhZWQ5NjQxOTI2ODJmZWE4YjJiYmExZTIxZmE5OWUxOWZjZjgwZDFlZWMwMjkyZDQwZWU1NWI4YWIzODllNQ&amp;expires_in=3600&amp;token_type=bearer&amp;refresh_token=YzQ1YjRhODk2YzJiYTZmMzNiNjI5ZjI2MDI3ZmMwMDg3MjkxMDdhYmE5YjBlYzRlZmM2M2Q0NTM3ZjFmZDZiYQ
</code></pre>

<h2>Password flow</h2>

<p>Let&rsquo;s say you have no luxury of redirecting user to some website, then handle redirect call, all you have is just an application which is able to send HTTP requests. And you still want to somehow authenticate user on the server side, and all you have is username and password.</p>

<p>Request:</p>

<pre><code>PROVIDER_HOST/oauth/v2/token?client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET&amp;grant_type=password&amp;username=USERNAME&amp;password=PASSWORD
</code></pre>

<p>Response:</p>

<pre><code>{"access_token":"MjY1MWRhYTAyZDZlOTEyN2EzNTg4MGMwMTcyYjczY2Y0MWI3NzZjODc1OGM2NDdjODgxZjY3YzEyMDdhZjU0Yg","expires_in":3600,"token_type":"bearer","scope":null,"refresh_token":"MDNmNzBmNWQ2NzdhYWVmYjE2NjI3ZjAyZTM4Y2Q1NDRiNDY1YjUyZGE1ZDk0ODZjYmU0MDM0NTQxNjhiZmU3ZA"}
</code></pre>

<h2>Client Credentials</h2>

<p>This one is the most simplistic flow of them all. You just need to provide CLIENT_ID and CLIENT_SECRET.</p>

<pre><code>PROVIDER_HOST/oauth/v2/token?client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET&amp;grant_type=client_credentials
</code></pre>

<p>Response will be</p>

<pre><code>{"access_token":"YTk0YTVjZDY0YWI2ZmE0NjRiODQ4OWIyNjZkNjZlMTdiZGZlNmI3MDNjZGQwYTZkMDNiMjliNDg3NWYwZWI0MQ","expires_in":3600,"token_type":"bearer","scope":"user","refresh_token":"ZDU1MDY1OTc4NGNlNzQ5NWFiYTEzZTE1OGY5MWNjMmViYTBiNmRjOTNlY2ExNzAxNWRmZTM1NjI3ZDkwNDdjNQ"}
</code></pre>

<h2>Refresh flow</h2>

<p>Before I mentioned that access_tokens have a lifetime of one hour, after which they will expire. With every access_token you were provided a refresh_token. You can exchange refresh token and get a new pair of access_token and refresh_token</p>

<pre><code>PROVIDER_HOST/oauth/v2/token?client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET&amp;grant_type=refresh_token&amp;refresh_token=REFRESH_TOKEN
</code></pre>

<p>response</p>

<pre><code>{"access_token":NEW_ACCESS_TOKEN,"expires_in":3600,"token_type":"bearer","scope":"user","refresh_token":"NEW_REFRESH_TOKEN"}
</code></pre>

<h2>Let&rsquo;s not fail or using the access_token</h2>

<p>Remember our failed attempt to request an API at the beginning of the article? Let&rsquo;s try again.</p>

<p>Request</p>

<pre><code>PROVIDER_HOST/api/articles?access_token=ACCESS_TOKEN
</code></pre>

<p>Response</p>

<pre><code>["article1","article2","article3"]
</code></pre>

<p>Seems like a proper response, does it?</p>

<p>Let&rsquo;s try the other request, which is supposed to maintain user session with the access_token.</p>

<p>Request</p>

<pre><code>PROVIDER_HOST/api/user?access_token=ACCESS_TOKEN
</code></pre>

<p>If you obtained your access_token through Authorization Code, Implicit Grant or Password, you should see a JSON representation of the user object.</p>

<pre><code>{"id":1,"username":"user1"}
</code></pre>

<p>If that was the Client Credentials, ACCESS_TOKEN doesn&rsquo;t contain any user information association with it, therefore there can&rsquo;t be any user information retrieved, as the response suggests</p>

<pre><code>{"message":"User is not identified"}
</code></pre>

<p>In the next part we will define a custom Grant type which allows us to retrieve access_token based on API Key.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OAuth2 Explained: Part 2 - Setting up OAuth2 with Symfony2 using FOSOAuthServerBundle]]></title>
    <link href="http://iamtankist.github.io/blog/2013/07/17/oauth2-explained-part-2-setting-up-oauth2-with-symfony2-using-fosoauthserverbundle/"/>
    <updated>2013-07-17T10:35:00+02:00</updated>
    <id>http://iamtankist.github.io/blog/2013/07/17/oauth2-explained-part-2-setting-up-oauth2-with-symfony2-using-fosoauthserverbundle</id>
    <content type="html"><![CDATA[<ul>
<li><a href="http://blog.tankist.de/blog/2013/07/16/oauth2-explained-part-1-principles-and-terminology/">Part 1 &ndash; Principles and Terminology</a></li>
<li><a href="http://blog.tankist.de/blog/2013/07/17/oauth2-explained-part-2-setting-up-oauth2-with-symfony2-using-fosoauthserverbundle/">Part 2 &ndash; Setting up OAuth2 with Symfony2 using FOSOAuthServerBundle</a></li>
<li><a href="http://blog.tankist.de/blog/2013/07/18/oauth2-explained-part-3-using-oauth2-with-your-bare-hands/">Part 3 &ndash; Using OAuth2 with your bare hands</a></li>
<li><a href="http://blog.tankist.de/blog/2013/08/20/oauth2-explained-part-4-implementing-custom-grant-type-symfony2-fosoauthserverbundle/">Part 4 &ndash; Implementing Custom Grant Type</a></li>
<li>Part 5 &ndash; Implementing OAuth2 Client with Symfony2</li>
</ul>


<h2>Prerequisites</h2>

<p>Let&rsquo;s assume you already have a project running on Symfony2 with Doctrine2, and you would like to enable some OAuth2 provider functionality on it. In case you still don&rsquo;t have a running Symfony2 installation, please go through <a href="http://symfony.com/doc/current/book/installation.html">Symfony Book: Installation</a> instructions and get a fresh copy of a Symfony2.</p>

<p>Also your project already, most probably, should has a User Entity, if not you can create something like this one.</p>

<!-- more -->


<p>``` php
  &lt;?php</p>

<pre><code>// src/Acme/DemoBundle/Entity/User.php

namespace Acme\DemoBundle\Entity;

use Symfony\Component\Security\Core\User\UserInterface;
use Doctrine\ORM\Mapping as ORM;

/**
 * Acme\UserBundle\Entity\User
 *
 * @ORM\Table(name="acme_users")
 * @ORM\Entity(repositoryClass="Acme\DemoBundle\Repository\UserRepository")
 */
class User implements UserInterface, \Serializable
{
    /**
     * @ORM\Column(type="integer")
     * @ORM\Id
     * @ORM\GeneratedValue(strategy="AUTO")
     */
    private $id;

    /**
     * @ORM\Column(type="string", length=25, unique=true)
     */
    private $username;

    /**
     * @ORM\Column(type="string", length=25, unique=true)
     */
    private $email;

    /**
     * @ORM\Column(type="string", length=32)
     */
    private $salt;

    /**
     * @ORM\Column(type="string", length=40)
     */
    private $password;

    /**
     * @ORM\Column(name="is_active", type="boolean")
     */
    private $isActive;

    public function __construct()
    {
        $this-&gt;isActive = true;
        $this-&gt;salt = md5(uniqid(null, true));
    }

    public function getId(){
        return $this-&gt;id;
    }

    /**
     * @inheritDoc
     */
    public function getUsername()
    {
        return $this-&gt;username;
    }

    /**
     * @inheritDoc
     */
    public function setUsername($username)
    {
        $this-&gt;username = $username;
        $this-&gt;email = $username;
    }

    /**
     * @inheritDoc
     */
    public function getSalt()
    {
        return $this-&gt;salt;
    }

    public function setSalt($salt)
    {
        $this-&gt;salt = $salt;
    }

    /**
     * @inheritDoc
     */
    public function getPassword()
    {
        return $this-&gt;password;
    }

    public function setPassword($password)
    {
        $this-&gt;password = $password;
    }

    /**
     * @inheritDoc
     */
    public function getRoles()
    {
        return array('ROLE_USER');
    }

    /**
     * @inheritDoc
     */
    public function eraseCredentials()
    {
    }

    /**
     * @see \Serializable::serialize()
     */
    public function serialize()
    {
        return serialize(
            array(
                $this-&gt;id,
            )
        );
    }

    /**
     * @see \Serializable::unserialize()
     */
    public function unserialize($serialized)
    {
        list (
            $this-&gt;id,
            ) = unserialize($serialized);
    }
}
</code></pre>

<p>```</p>

<p>We are going to need a user provider as well.</p>

<p>``` php</p>

<pre><code>&lt;?php
    // src/Acme/DemoBundle/Provider/UserProvider.php

    namespace Acme\DemoBundle\Provider;

    use Symfony\Component\Security\Core\User\UserInterface;
    use Symfony\Component\Security\Core\User\UserProviderInterface;
    use Symfony\Component\Security\Core\Exception\UsernameNotFoundException;
    use Symfony\Component\Security\Core\Exception\UnsupportedUserException;
    use Doctrine\Common\Persistence\ObjectRepository;
    use Doctrine\ORM\NoResultException;

    class UserProvider implements UserProviderInterface
    {
        protected $userRepository;

        public function __construct(ObjectRepository $userRepository){
            $this-&gt;userRepository = $userRepository;
        }

        public function loadUserByUsername($username)
        {
            $q = $this-&gt;userRepository
                -&gt;createQueryBuilder('u')
                -&gt;where('u.username = :username OR u.email = :email')
                -&gt;setParameter('username', $username)
                -&gt;setParameter('email', $username)
                -&gt;getQuery();

            try {
                $user = $q-&gt;getSingleResult();
            } catch (NoResultException $e) {
                $message = sprintf(
                    'Unable to find an active admin AcmeDemoBundle:User object identified by "%s".',
                    $username
                );
                throw new UsernameNotFoundException($message, 0, $e);
            }

            return $user;
        }

        public function refreshUser(UserInterface $user)
        {
            $class = get_class($user);
            if (!$this-&gt;supportsClass($class)) {
                throw new UnsupportedUserException(
                    sprintf(
                        'Instances of "%s" are not supported.',
                        $class
                    )
                );
            }

            return $this-&gt;userRepository-&gt;find($user-&gt;getId());
        }

        public function supportsClass($class)
        {
            return $this-&gt;userRepository-&gt;getClassName() === $class
            || is_subclass_of($class, $this-&gt;userRepository-&gt;getClassName());
        }
    }
</code></pre>

<p>```</p>

<p>Now register the user manager, repository and provider in the Dependency Injection Container</p>

<p>``` xml</p>

<pre><code>&lt;!-- src/Acme/DemoBundle/Resources/config/services.xml --&gt;
&lt;parameters&gt;
    &lt;parameter key="platform.entity.user.class"&gt;Acme\DemoBundle\Entity\User&lt;/parameter&gt;
    &lt;parameter key="platform.user.provider.class"&gt;Acme\DemoBundle\Provider\UserProvider&lt;/parameter&gt;
&lt;/parameters&gt;

&lt;services&gt;
    &lt;service id="platform.user.manager" class="Doctrine\ORM\EntityManager"
             factory-service="doctrine" factory-method="getManagerForClass"&gt;
        &lt;argument&gt;%platform.entity.user.class%&lt;/argument&gt;
    &lt;/service&gt;

    &lt;service id="platform.user.repository"
             class="Acme\DemoBundle\Repository\UserRepository"
             factory-service="platform.user.manager" factory-method="getRepository"&gt;
        &lt;argument&gt;%platform.entity.user.class%&lt;/argument&gt;
    &lt;/service&gt;

    &lt;service id="platform.user.provider" class="%platform.user.provider.class%"&gt;
        &lt;argument type="service" id="platform.user.repository" /&gt;
    &lt;/service&gt;
&lt;/services&gt;
</code></pre>

<p>```</p>

<p>Ok, now we are good to go with setting up OAuthServerBundle on our platform.</p>

<h2>Installing FOSOAuthServerBundle</h2>

<p>To install FOSOauthServerBundle, execute the following in your command line:</p>

<p>``` sh</p>

<pre><code> php composer.phar require friendsofsymfony/oauth-server-bundle dev-master
</code></pre>

<p>```</p>

<p>This will include the package to the composer.json and install it.</p>

<p>Now you need to enable this bundle in the Kernel:
``` php</p>

<pre><code>&lt;?php
// app/AppKernel.php

public function registerBundles()
{
    $bundles = array(
        // ...
        new FOS\OAuthServerBundle\FOSOAuthServerBundle(),
    );
} 
</code></pre>

<p>```
Now we need to create several additional entities.</p>

<h3>Client Entity</h3>

<p>``` php</p>

<pre><code>// src/Acme/DemoBundle/Entity/Client.php

namespace Acme\DemoBundle\Entity;

use FOS\OAuthServerBundle\Entity\Client as BaseClient;
use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Entity
 */
class Client extends BaseClient
{
    /**
     * @ORM\Id
     * @ORM\Column(type="integer")
     * @ORM\GeneratedValue(strategy="AUTO")
     */
    protected $id;

    public function __construct()
    {
        parent::__construct();
    }
}
</code></pre>

<p>```</p>

<h3>AccessToken Entity</h3>

<p>``` php</p>

<pre><code>&lt;?php
// src/Acme/DemoBundle/Entity/AccessToken.php

namespace Acme\DemoBundle\Entity;

use FOS\OAuthServerBundle\Entity\AccessToken as BaseAccessToken;
use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Entity
 */
class AccessToken extends BaseAccessToken
{
    /**
     * @ORM\Id
     * @ORM\Column(type="integer")
     * @ORM\GeneratedValue(strategy="AUTO")
     */
    protected $id;

    /**
     * @ORM\ManyToOne(targetEntity="Client")
     * @ORM\JoinColumn(nullable=false)
     */
    protected $client;

    /**
     * @ORM\ManyToOne(targetEntity="User")
     */
    protected $user;
}
</code></pre>

<p>```</p>

<h3>RefreshToken Entity</h3>

<p>``` php</p>

<pre><code>&lt;?php
// src/Acme/DemoBundle/Entity/RefreshToken.php

namespace Acme\DemoBundle\Entity;

use FOS\OAuthServerBundle\Entity\RefreshToken as BaseRefreshToken;
use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Entity
 */
class RefreshToken extends BaseRefreshToken
{
    /**
     * @ORM\Id
     * @ORM\Column(type="integer")
     * @ORM\GeneratedValue(strategy="AUTO")
     */
    protected $id;

    /**
     * @ORM\ManyToOne(targetEntity="Client")
     * @ORM\JoinColumn(nullable=false)
     */
    protected $client;

    /**
     * @ORM\ManyToOne(targetEntity="User")
     */
    protected $user;
}
</code></pre>

<p>```</p>

<h3>AuthCode Entity</h3>

<p>``` php</p>

<pre><code>&lt;?php
// src/Acme/DemoBundle/Entity/AuthCode.php

namespace Acme\DemoBundle\Entity;

use FOS\OAuthServerBundle\Entity\AuthCode as BaseAuthCode;
use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Entity
 */
class AuthCode extends BaseAuthCode
{
    /**
     * @ORM\Id
     * @ORM\Column(type="integer")
     * @ORM\GeneratedValue(strategy="AUTO")
     */
    protected $id;

    /**
     * @ORM\ManyToOne(targetEntity="Client")
     * @ORM\JoinColumn(nullable=false)
     */
    protected $client;

    /**
     * @ORM\ManyToOne(targetEntity="User")
     */
    protected $user;
}
</code></pre>

<p>```
Please pay attention to the user entity namespace, since your User entity might be in other bundle, make sure that namespaces pointing to User entity are correct.</p>

<p>Ok, entities are created, now it&rsquo;s time to create a separate login page for users coming from OAuth direction. I prefer to use separate login forms to handle this, because usually inside the project you have different redirection policies, and in case of OAuth you strictly need to redirect back to referrer. But of course feel free to reuse your already existing login form inside the project, just make sure it redirects you to the right place then.</p>

<p>Here is the controller responsible for the login form
``` php</p>

<pre><code>&lt;?php

# src/Acme/DemoBundle/Controller/SecurityController.php

namespace Acme\DemoBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Security\Core\SecurityContext;

class SecurityController extends Controller
{
    public function loginAction(Request $request)
    {
        $session = $request-&gt;getSession();

        if ($request-&gt;attributes-&gt;has(SecurityContext::AUTHENTICATION_ERROR)) {
            $error = $request-&gt;attributes-&gt;get(SecurityContext::AUTHENTICATION_ERROR);
        } elseif (null !== $session &amp;&amp; $session-&gt;has(SecurityContext::AUTHENTICATION_ERROR)) {
            $error = $session-&gt;get(SecurityContext::AUTHENTICATION_ERROR);
            $session-&gt;remove(SecurityContext::AUTHENTICATION_ERROR);
        } else {
            $error = '';
        }

        if ($error) {
            $error = $error-&gt;getMessage(
            ); // WARNING! Symfony source code identifies this line as a potential security threat.
        }

        $lastUsername = (null === $session) ? '' : $session-&gt;get(SecurityContext::LAST_USERNAME);

        return $this-&gt;render(
            'AcmeDemoBundle:Security:login.html.twig',
            array(
                'last_username' =&gt; $lastUsername,
                'error' =&gt; $error,
            )
        );
    }

    public function loginCheckAction(Request $request)
    {

    }
}
</code></pre>

<p><code>
and here is the corresponding minimal template
</code> php</p>

<pre><code>{# src/Acme/DemoBundle/Resources/views/Security/login.html.twig #}
&lt;div class="form"&gt;
    &lt;form id="login" class="vertical" action="" method="post"&gt;
        &lt;div class="form_title"&gt;
            OAuth Authorization
        &lt;/div&gt;
        
        &lt;div class="form_item"&gt;
            &lt;div class="form_label"&gt;&lt;label for="username"&gt;Username&lt;/label&gt;:&lt;/div&gt;
            &lt;div class="form_widget"&gt;&lt;input type="text" id="username" name="_username" /&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="form_item"&gt;
            &lt;div class="form_label"&gt;&lt;label for="password"&gt;Password&lt;/label&gt;:&lt;/div&gt;
            &lt;div class="form_widget"&gt;&lt;input type="password" id="password" name="_password" /&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="form_button"&gt;
            &lt;input type="submit" id="_submit" name="_submit" value="Log In" /&gt;
        &lt;/div&gt;
    &lt;/form&gt;
&lt;/div&gt;
</code></pre>

<p>```</p>

<h3>Configuration</h3>

<p>Following goes into <strong>security.yml</strong>
``` yaml</p>

<pre><code>security:
    encoders:
        Acme\DemoBundle\Entity\User:
            algorithm:        sha1
            encode_as_base64: false
            iterations:       1

    role_hierarchy:
        ROLE_ADMIN:       ROLE_USER
        ROLE_SUPER_ADMIN: ROLE_ADMIN

    providers:
        user_provider:
            id: platform.user.provider


    firewalls:
        dev:
            pattern:  ^/(_(profiler|wdt)|css|images|js)/
            security: false

        login:
            pattern:  ^/demo/secured/login$
            security: false


        oauth_token:
            pattern:    ^/oauth/v2/token
            security:   false

        secured_area:
            pattern:    ^/demo/secured/
            form_login:
                provider: user_provider
                check_path: _security_check
                login_path: _demo_login
            logout:
                path:   _demo_logout
                target: _demo
            #anonymous: ~
            #http_basic:
            #    realm: "Secured Demo Area"

        oauth_authorize:
            pattern:    ^/oauth/v2/auth
            form_login:
                provider: user_provider
                check_path: _security_check
                login_path: _demo_login
            anonymous: true

        api:
            pattern:    ^/api
            fos_oauth:  true
            stateless:  true

    access_control:
        # You can omit this if /api can be accessed both authenticated and anonymously
        - { path: ^/api, roles: [ IS_AUTHENTICATED_FULLY ] }
        - { path: ^/demo/secured/hello/admin/, roles: ROLE_ADMIN }
        #- { path: ^/login, roles: IS_AUTHENTICATED_ANONYMOUSLY, requires_channel: https }
</code></pre>

<p>```</p>

<p>following goes to <strong>routing.yml</strong>
``` yaml</p>

<pre><code># app/config/routing.yml
fos_oauth_server_token:
    resource: "@FOSOAuthServerBundle/Resources/config/routing/token.xml"

fos_oauth_server_authorize:
    resource: "@FOSOAuthServerBundle/Resources/config/routing/authorize.xml"

acme_oauth_server_auth_login:
    pattern:  /oauth/v2/auth_login
    defaults: { _controller: AcmeDemoBundle:Security:login }

acme_oauth_server_auth_login_check:
    pattern:  /oauth/v2/auth_login_check
    defaults: { _controller: AcmeDemoBundle:Security:loginCheck }
</code></pre>

<p>```</p>

<p>and finally <strong>config.yml</strong>
``` yaml</p>

<pre><code># app/config/config.yml
fos_oauth_server:
    db_driver: orm
    client_class:        Acme\DemoBundle\Entity\Client
    access_token_class:  Acme\DemoBundle\Entity\AccessToken
    refresh_token_class: Acme\DemoBundle\Entity\RefreshToken
    auth_code_class:     Acme\DemoBundle\Entity\AuthCode
    service:
        user_provider: platform.user.provider
        options:
            supported_scopes: user
</code></pre>

<p>```</p>

<p>Now, when all configurations done, time to update database structure
``` sh</p>

<pre><code>php app/console doctrine:schema:update --force
</code></pre>

<p>```</p>

<h3>Client Creation</h3>

<p>first thing you need to do is give the platform ability to easily create clients for OAuth protected communication, and a protected API call.</p>

<p>Create a command file
``` php</p>

<pre><code>&lt;?php
# src/Acme/DemoBundle/Command/CreateClientCommand.php   
namespace Acme\DemoBundle\Command;

use Symfony\Bundle\FrameworkBundle\Command\ContainerAwareCommand;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

class CreateClientCommand extends ContainerAwareCommand
{
    protected function configure()
    {
        $this
            -&gt;setName('acme:oauth-server:client:create')
            -&gt;setDescription('Creates a new client')
            -&gt;addOption(
                'redirect-uri',
                null,
                InputOption::VALUE_REQUIRED | InputOption::VALUE_IS_ARRAY,
                'Sets redirect uri for client. Use this option multiple times to set multiple redirect URIs.',
                null
            )
            -&gt;addOption(
                'grant-type',
                null,
                InputOption::VALUE_REQUIRED | InputOption::VALUE_IS_ARRAY,
                'Sets allowed grant type for client. Use this option multiple times to set multiple grant types..',
                null
            )
            -&gt;setHelp(
                &lt;&lt;&lt;EOT
                    The &lt;info&gt;%command.name%&lt;/info&gt;command creates a new client.

&lt;info&gt;php %command.full_name% [--redirect-uri=...] [--grant-type=...] name&lt;/info&gt;

EOT
            );
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $clientManager = $this-&gt;getContainer()-&gt;get('fos_oauth_server.client_manager.default');
        $client = $clientManager-&gt;createClient();
        $client-&gt;setRedirectUris($input-&gt;getOption('redirect-uri'));
        $client-&gt;setAllowedGrantTypes($input-&gt;getOption('grant-type'));
        $clientManager-&gt;updateClient($client);
        $output-&gt;writeln(
            sprintf(
                'Added a new client with public id &lt;info&gt;%s&lt;/info&gt;, secret &lt;info&gt;%s&lt;/info&gt;',
                $client-&gt;getPublicId(),
                $client-&gt;getSecret()
            )
        );
    }
}
</code></pre>

<p>```</p>

<p>In order to test it, please execute
``` sh</p>

<pre><code> php app/console acme:oauth-server:client:create --redirect-uri="http://clinet.local/" --grant-type="authorization_code" --grant-type="password" --grant-type="refresh_token" --grant-type="token" --grant-type="client_credentials"
</code></pre>

<p><code>
this will register an OAuth client on the platform side, and will Output something like this (of course, you will see slightly different output)
</code></p>

<pre><code>Added a new client with public id 5_ebg354gknv48kc88o8oogwokckco0o40sc000cowc8soosw0k, secret 5ub5upfxih0k8g44w00ogwc4swog4088o8444sssos8k888o8g
</code></pre>

<p>```
Keep those public_id and secret somewhere private, since that&rsquo;s the credentials for the client application to access your backend using oauth.</p>

<h3>Check if it works</h3>

<p>Execute the following request in your browser
```</p>

<pre><code>http://portal.local/app_dev.php/oauth/v2/token?client_id=5_ebg354gknv48kc88o8oogwokckco0o40sc000cowc8soosw0k&amp;client_secret=5ub5upfxih0k8g44w00ogwc4swog4088o8444sssos8k888o8g&amp;grant_type=client_credentials
</code></pre>

<p><code>
If you see response like this one, then we did everything correctly, otherwise, leave a comment, or contact me over twitter, let's figure this out together ;)
</code> json</p>

<pre><code>{"access_token":"YTk0YTVjZDY0YWI2ZmE0NjRiODQ4OWIyNjZkNjZlMTdiZGZlNmI3MDNjZGQwYTZkMDNiMjliNDg3NWYwZWI0MQ","expires_in":3600,"token_type":"bearer","scope":"user","refresh_token":"ZDU1MDY1OTc4NGNlNzQ5NWFiYTEzZTE1OGY5MWNjMmViYTBiNmRjOTNlY2ExNzAxNWRmZTM1NjI3ZDkwNDdjNQ"}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OAuth2 Explained: Part 1 - Principles and Terminology]]></title>
    <link href="http://iamtankist.github.io/blog/2013/07/16/oauth2-explained-part-1-principles-and-terminology/"/>
    <updated>2013-07-16T15:35:00+02:00</updated>
    <id>http://iamtankist.github.io/blog/2013/07/16/oauth2-explained-part-1-principles-and-terminology</id>
    <content type="html"><![CDATA[<ul>
<li><a href="http://blog.tankist.de/blog/2013/07/16/oauth2-explained-part-1-principles-and-terminology/">Part 1 &ndash; Principles and Terminology</a></li>
<li><a href="http://blog.tankist.de/blog/2013/07/17/oauth2-explained-part-2-setting-up-oauth2-with-symfony2-using-fosoauthserverbundle/">Part 2 &ndash; Setting up OAuth2 with Symfony2 using FOSOAuthServerBundle</a></li>
<li><a href="http://blog.tankist.de/blog/2013/07/18/oauth2-explained-part-3-using-oauth2-with-your-bare-hands/">Part 3 &ndash; Using OAuth2 with your bare hands</a></li>
<li><a href="http://blog.tankist.de/blog/2013/08/20/oauth2-explained-part-4-implementing-custom-grant-type-symfony2-fosoauthserverbundle/">Part 4 &ndash; Implementing Custom Grant Type</a></li>
<li>Part 5 &ndash; Implementing OAuth2 Client with Symfony2</li>
</ul>


<h2>Why OAuth and a bit of Terminology</h2>

<p>Before we dive in into technical aspects of OAuth, let&rsquo;s get the OAuth terminology straight.</p>

<h3>Provider</h3>

<p>So you have a functional platform, gathered some data and functionality and now it&rsquo;s time when you need to provide this data and functionality over an API to your users, mobile devices and other platforms. You will be an OAuth <strong>Provider</strong>, rather soon.</p>

<!-- more -->


<h3>Access Token</h3>

<p>Let&rsquo;s say you have an API to protect. You need to provide some functionality over it, including passing back and forth sensible data.</p>

<p>Let&rsquo;s assume, a user is able to log in using mobile application and request his current balance on his account. Simplest thing comes to your mind:</p>

<blockquote><p>/user/15/balance</p></blockquote>

<p>where 15 is user&rsquo;s id? Bad idea. Everyone who is able to use any kind of development console for the browser can change user id and get access to a sensible data. How can you solve this?</p>

<p>Right. The same way PHP Sessions work for example. You generate a token, something similar to PHPSESSID, you create it at the moment when user logs in, pass this token back and forth with each request, and that&rsquo;s how the server knows that this is the user associated with current session. There is no way one can manipulate session token in order to get data for specific user. And then when the user logs out you remove the token, or it just gets expired after awhile.</p>

<p>Congratulations, you just invented the main entity of OAuth &ndash; <strong>Access Token</strong>.</p>

<p>In OAuth world obtaining Access Token means getting access to the application. Once you get it, you attach the access token to each of your requests, and Provider can uniquely identify who you are and what actions are you allowed to perform. Obtained Access Token? Game over, You Won!</p>

<h3>Clients and Scopes</h3>

<p>What if, we need a special kind of service which is able to set user balance, and that&rsquo;s for each and one of them. One solution (and your operations team will really like it) you just give it another endpoint, and this endpoint is open only for white-listed IPs. If you googled for this article, most probably you already know at least 5 reasons why this solution stinks.</p>

<p>A better solution would be: You are able, somehow, on the backend side, distinguish between different type of consumers for your applications. Some are more privileged, some are less. Some are allowed to request only their own balance, some clients are allowed to manipulate this balances for all possible users. So we need a mechanism to specify different <strong>Clients</strong>  and give them different privileges or in OAuth terminology &ndash; <strong>Scopes</strong>. You most probably don&rsquo;t need a Client for each User, you are fine with one Client for all Users, one Client for a MobileApp, one Client for an accounting application. Each client gets a pair of credentials. <strong>Client ID</strong> and <strong>Client Secret</strong>. You need those in order to identify your client.</p>

<h3>Grant Types</h3>

<p>If you ever used Facebook Login for websites, you know how the most popular Grant Type works. You get redirected to Provider&rsquo;s website, if you are not yet logged in, the Provider offers you a login, then it asks for certain permissions, what can the Client do on your behalf, and then redirects you back. That&rsquo;s the <strong>Authoritation_Code</strong> grant.</p>

<p>But then we have our accounting application. There&rsquo;s no login associated with it, no web interface, it&rsquo;s just a dumb-as-hell cronjob which just wants to trigger some HTTP requests to update user balances on your side. Then we use <strong>Client_Credentials</strong> grant type. It means in order to obtain access to the api, a client should only present his Client Id and Client Password.</p>

<p>Or an intermediate grant type &ndash; password. You provide a client id, client secret, username, password, and the Provider issues an access token, which is connected to this user, so when you get a request, you can identify which user made it.</p>

<p>So the <strong>Grant Type</strong> represents the flow needed for the <strong>Client</strong> to obtain <strong>Access Token</strong>.</p>

<p>In OAuth2 there are five Grant Types that are defined by the standard, but you have an ability to implement a custom one for your needs.</p>

<p>For example you need to identify user not by username/password, but you give them API keys, in order not to transmit password in clear text over API. Then you need to implement a grant type for that flow. How to do that in details will be described in the 5th part of this tutorial.</p>
]]></content>
  </entry>
  
</feed>
